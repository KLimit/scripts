#! /usr/bin/python3
"""Performance-conscious attempt to clean up files with empty first lines."""


import argparse
from glob import glob
import linecache
import os
import re
import shutil
import subprocess


EMPTYLINE = re.compile(r'^\s*$')


def args(argv=None):
    """Parse arguments for the main function."""
    pser = argparse.ArgumentParser()
    pser.add_argument(
        'path',
        type=glob,
        help='glob-type search path',
    )
    pser.add_argument(
        '-v',
        '--verbose',
        action='store_true',
        help='print detailed report of the process',
    )
    pser.add_argument(
        '-n',
        '--dry-run',
        action='store_true',
        help='Only print what files would be affected; do not modify any'
    )
    pser.add_argument(
        '--keep-temp',
        dest='keep',
        action='store_true',
        help='keep the temporary files generated by the process'
    )
    args = pser.parse_args(argv)
    return vars(args)


def main(path, verbose, dry_run, keep):
    """Go through all the files in path and clean them up."""
    files = [f for f in path if line_empty(f)]
    if verbose:
        if files:
            print('will be trimming the first line of the following files:')
            print('\n'.join(files))
        else:
            print('no files to trim')
    tail = shutil.which('tail')
    if not dry_run:
        for filename in files:
            cleanline(filename, tail, keep)
        if verbose:
            print('files trimmed')


def line_empty(filename, line=1):
    """Return whether line line is empty (incl. whitespace)."""
    emptyline = EMPTYLINE.match(linecache.getline(filename, line).strip())
    emptyfile = os.path.getsize(filename) == 0
    return emptyline and not emptyfile


def cleanline(filename, tail, keep):
    """Use external tail to remove line with a uuid tmp to avoid collision."""
    origfile = filename + '_orig'
    shutil.move(filename, origfile)
    with open(filename, 'w') as finalfile:
        subprocess.run(
            [tail, '-n', '+2', origfile],
            stdout=finalfile,
            check=True,
        )
    if not keep:
        os.remove(origfile)


if __name__ == '__main__':
    main(**args())
